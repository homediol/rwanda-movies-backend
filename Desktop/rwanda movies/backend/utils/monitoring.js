const os = require('os');\nconst sequelize = require('../config/database');\n\n/**\n * System monitoring utilities\n */\nclass SystemMonitor {\n  constructor() {\n    this.startTime = Date.now();\n    this.metrics = {\n      requests: 0,\n      errors: 0,\n      dbQueries: 0,\n      dbErrors: 0\n    };\n  }\n\n  /**\n   * Get system memory usage\n   */\n  getMemoryUsage() {\n    const processMemory = process.memoryUsage();\n    const systemMemory = {\n      total: os.totalmem(),\n      free: os.freemem(),\n      used: os.totalmem() - os.freemem()\n    };\n\n    return {\n      process: {\n        rss: Math.round(processMemory.rss / 1024 / 1024), // MB\n        heapTotal: Math.round(processMemory.heapTotal / 1024 / 1024),\n        heapUsed: Math.round(processMemory.heapUsed / 1024 / 1024),\n        external: Math.round(processMemory.external / 1024 / 1024),\n        arrayBuffers: Math.round(processMemory.arrayBuffers / 1024 / 1024)\n      },\n      system: {\n        total: Math.round(systemMemory.total / 1024 / 1024), // MB\n        free: Math.round(systemMemory.free / 1024 / 1024),\n        used: Math.round(systemMemory.used / 1024 / 1024),\n        usage: Math.round((systemMemory.used / systemMemory.total) * 100) // %\n      }\n    };\n  }\n\n  /**\n   * Get CPU usage\n   */\n  getCPUUsage() {\n    const cpus = os.cpus();\n    const loadAvg = os.loadavg();\n\n    return {\n      cores: cpus.length,\n      model: cpus[0].model,\n      speed: cpus[0].speed,\n      loadAverage: {\n        '1min': loadAvg[0].toFixed(2),\n        '5min': loadAvg[1].toFixed(2),\n        '15min': loadAvg[2].toFixed(2)\n      },\n      usage: this.calculateCPUUsage(cpus)\n    };\n  }\n\n  /**\n   * Calculate CPU usage percentage\n   */\n  calculateCPUUsage(cpus) {\n    let totalIdle = 0;\n    let totalTick = 0;\n\n    cpus.forEach(cpu => {\n      for (let type in cpu.times) {\n        totalTick += cpu.times[type];\n      }\n      totalIdle += cpu.times.idle;\n    });\n\n    const idle = totalIdle / cpus.length;\n    const total = totalTick / cpus.length;\n    const usage = 100 - ~~(100 * idle / total);\n\n    return Math.max(0, Math.min(100, usage));\n  }\n\n  /**\n   * Get database connection statistics\n   */\n  async getDatabaseStats() {\n    try {\n      const pool = sequelize.connectionManager.pool;\n      const health = await sequelize.healthCheck();\n      \n      return {\n        status: health.status,\n        connections: {\n          total: pool.size || 0,\n          active: pool.used ? pool.used.length : 0,\n          idle: pool.available ? pool.available.length : 0,\n          pending: pool.pending ? pool.pending.length : 0\n        },\n        config: {\n          max: sequelize.options.pool.max,\n          min: sequelize.options.pool.min,\n          acquire: sequelize.options.pool.acquire,\n          idle: sequelize.options.pool.idle\n        }\n      };\n    } catch (error) {\n      return {\n        status: 'error',\n        error: error.message,\n        connections: { total: 0, active: 0, idle: 0, pending: 0 }\n      };\n    }\n  }\n\n  /**\n   * Get application metrics\n   */\n  getAppMetrics() {\n    const uptime = Date.now() - this.startTime;\n    \n    return {\n      uptime: {\n        ms: uptime,\n        seconds: Math.floor(uptime / 1000),\n        minutes: Math.floor(uptime / 1000 / 60),\n        hours: Math.floor(uptime / 1000 / 60 / 60),\n        formatted: this.formatUptime(uptime)\n      },\n      requests: this.metrics.requests,\n      errors: this.metrics.errors,\n      dbQueries: this.metrics.dbQueries,\n      dbErrors: this.metrics.dbErrors,\n      errorRate: this.metrics.requests > 0 ? \n        ((this.metrics.errors / this.metrics.requests) * 100).toFixed(2) + '%' : '0%',\n      dbErrorRate: this.metrics.dbQueries > 0 ? \n        ((this.metrics.dbErrors / this.metrics.dbQueries) * 100).toFixed(2) + '%' : '0%'\n    };\n  }\n\n  /**\n   * Format uptime in human readable format\n   */\n  formatUptime(ms) {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    if (days > 0) return `${days}d ${hours % 24}h ${minutes % 60}m`;\n    if (hours > 0) return `${hours}h ${minutes % 60}m ${seconds % 60}s`;\n    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\n    return `${seconds}s`;\n  }\n\n  /**\n   * Get comprehensive system status\n   */\n  async getSystemStatus() {\n    const [memory, cpu, database, app] = await Promise.all([\n      Promise.resolve(this.getMemoryUsage()),\n      Promise.resolve(this.getCPUUsage()),\n      this.getDatabaseStats(),\n      Promise.resolve(this.getAppMetrics())\n    ]);\n\n    return {\n      timestamp: new Date().toISOString(),\n      status: this.determineOverallStatus(memory, cpu, database),\n      memory,\n      cpu,\n      database,\n      application: app,\n      system: {\n        platform: os.platform(),\n        arch: os.arch(),\n        nodeVersion: process.version,\n        hostname: os.hostname()\n      }\n    };\n  }\n\n  /**\n   * Determine overall system status\n   */\n  determineOverallStatus(memory, cpu, database) {\n    // Check for critical issues\n    if (database.status === 'error') return 'critical';\n    if (memory.process.heapUsed > 1000) return 'warning'; // Over 1GB\n    if (memory.system.usage > 90) return 'warning'; // Over 90% system memory\n    if (cpu.usage > 80) return 'warning'; // Over 80% CPU\n    \n    return 'healthy';\n  }\n\n  /**\n   * Increment request counter\n   */\n  incrementRequests() {\n    this.metrics.requests++;\n  }\n\n  /**\n   * Increment error counter\n   */\n  incrementErrors() {\n    this.metrics.errors++;\n  }\n\n  /**\n   * Increment database query counter\n   */\n  incrementDbQueries() {\n    this.metrics.dbQueries++;\n  }\n\n  /**\n   * Increment database error counter\n   */\n  incrementDbErrors() {\n    this.metrics.dbErrors++;\n  }\n\n  /**\n   * Express middleware for request tracking\n   */\n  requestTracker() {\n    return (req, res, next) => {\n      this.incrementRequests();\n      \n      // Track response errors\n      const originalSend = res.send;\n      res.send = function(data) {\n        if (res.statusCode >= 400) {\n          monitor.incrementErrors();\n        }\n        return originalSend.call(this, data);\n      };\n      \n      next();\n    };\n  }\n\n  /**\n   * Start periodic monitoring\n   */\n  startMonitoring(intervalMs = 60000) { // Default: 1 minute\n    console.log(`üîç Starting system monitoring (interval: ${intervalMs}ms)`);\n    \n    setInterval(async () => {\n      try {\n        const status = await this.getSystemStatus();\n        \n        // Log warnings and critical issues\n        if (status.status === 'critical') {\n          console.error('üö® CRITICAL: System status is critical!', {\n            memory: status.memory.process.heapUsed + 'MB',\n            database: status.database.status,\n            timestamp: status.timestamp\n          });\n        } else if (status.status === 'warning') {\n          console.warn('‚ö†Ô∏è WARNING: System performance degraded', {\n            memory: status.memory.process.heapUsed + 'MB',\n            cpu: status.cpu.usage + '%',\n            systemMemory: status.memory.system.usage + '%',\n            timestamp: status.timestamp\n          });\n        }\n        \n        // Log periodic status (every 10 minutes)\n        if (status.application.uptime.minutes % 10 === 0) {\n          console.log('üìä System Status:', {\n            status: status.status,\n            uptime: status.application.uptime.formatted,\n            memory: status.memory.process.heapUsed + 'MB',\n            requests: status.application.requests,\n            dbConnections: status.database.connections.active\n          });\n        }\n      } catch (error) {\n        console.error('‚ùå Monitoring error:', error.message);\n      }\n    }, intervalMs);\n  }\n}\n\n// Create singleton instance\nconst monitor = new SystemMonitor();\n\nmodule.exports = {\n  SystemMonitor,\n  monitor,\n  // Export middleware\n  requestTracker: monitor.requestTracker.bind(monitor)\n};", "oldStr": "", "newStr": ""}]